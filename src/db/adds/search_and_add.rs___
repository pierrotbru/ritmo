use sqlx::Sqlite;
use sqlx::Transaction;
use sqlx::Row;
use crate::RitmoErr;

pub struct NewId {
    pub id: Option<i32>,
    pub added: bool,
}

pub enum IdAction {
    SearchId,
    AddId,
    RemoveId,
}

#[async_trait::async_trait]
pub trait SearchAndAdd {
    async fn search_and_add(
        &self,
        tx: &mut Transaction<'_, Sqlite>,
        table_name: &str,
        id_column: &str,
        name_column: &str,
        target: &str,
        add_it: IdAction,
    ) -> Result<NewId, RitmoErr>;
}

#[async_trait::async_trait]
impl SearchAndAdd for () {
    async fn search_and_add(
        &self,
        tx: &mut Transaction<'_, Sqlite>, // Modifica qui
        table_name: &str,
        id_column: &str,
        name_column: &str,
        target: &str,
        add_it: IdAction,
    ) -> Result<NewId, RitmoErr> {
        match add_it {
            IdAction::SearchId => {
                let query = format!("SELECT {} FROM {} WHERE {} = ?", id_column, table_name, name_column);
                let row = sqlx::query(&query)
                    .bind(target)
                    .fetch_optional(&mut **tx)
                    .await
                    .map_err(|e| RitmoErr::DatabaseQueryFailed(e.to_string()))?;

                match row {
                    Some(row) => {
                        let id: i32 = row.try_get(0).map_err(|e| RitmoErr::DatabaseQueryFailed(e.to_string()))?;
                        Ok(NewId { id: Some(id), added: false })
                    }
                    None => Ok(NewId { id: None, added: false }),
                }
            }
            IdAction::AddId => {
                match Self::search_and_add(self, tx, table_name, id_column, name_column, target, IdAction::SearchId).await {
                    Ok(NewId { id: Some(id), added: false }) => Ok(NewId { id: Some(id), added: false }),
                    Ok(NewId { id: None, added: false }) => {
                        let query = format!("INSERT INTO {} ({}) VALUES (?)", table_name, name_column);
                        let result = sqlx::query(&query)
                            .bind(target)
                            .execute(&mut **tx)
                            .await
                            .map_err(|e| RitmoErr::DatabaseInsertFailed(e.to_string()))?;

                        let inserted_id = result.last_insert_rowid() as i32;
                        Ok(NewId { id: Some(inserted_id), added: true })
                    }
                    Err(e) => Err(e),
                    _ => Err(RitmoErr::UnknownError("Unexpected result from search_and_add".to_string())),
                }
            }
            IdAction::RemoveId => {
                let query_select = format!("SELECT {} FROM {} WHERE {} = ?", id_column, table_name, name_column);
                let row = sqlx::query(&query_select)
                    .bind(target)
                    .fetch_optional(&mut **tx)
                    .await
                    .map_err(|e| RitmoErr::DatabaseQueryFailed(e.to_string()))?;

                match row {
                    Some(row) => {
                        let id: i32 = row.try_get(0).map_err(|e| RitmoErr::DatabaseQueryFailed(e.to_string()))?;
                        let query_delete = format!("DELETE FROM {} WHERE {} = ?", table_name, id_column);
                        sqlx::query(&query_delete)
                            .bind(id)
                            .execute(&mut **tx)
                            .await
                            .map_err(|e| RitmoErr::DatabaseDeleteFailed(e.to_string()))?;
                        Ok(NewId { id: Some(id), added: true })
                    }
                    None => Err(RitmoErr::RecordNotFound),
                }
            }
        }
    }
}
